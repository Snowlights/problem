### 题目

<p>有一些机器人分布在一条无限长的数轴上，他们初始坐标用一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 表示。当你给机器人下达命令时，它们以每秒钟一单位的速度开始移动。</p>

<p>给你一个字符串 <code>s</code> ，每个字符按顺序分别表示每个机器人移动的方向。<code>'L'</code> 表示机器人往左或者数轴的负方向移动，<code>'R'</code> 表示机器人往右或者数轴的正方向移动。</p>

<p>当两个机器人相撞时，它们开始沿着原本相反的方向移动。</p>

<p>请你返回指令重复执行 <code>d</code> 秒后，所有机器人之间两两距离之和。由于答案可能很大，请你将答案对 <code>10<sup>9</sup> + 7</code> 取余后返回。</p>

<p><b>注意：</b></p>

<ul>
	<li>对于坐标在 <code>i</code> 和 <code>j</code> 的两个机器人，<code>(i,j)</code> 和 <code>(j,i)</code> 视为相同的坐标对。也就是说，机器人视为无差别的。</li>
	<li>当机器人相撞时，它们 <strong>立即改变</strong> 它们的前进时间，这个过程不消耗任何时间。</li>
	<li>
	<p>当两个机器人在同一时刻占据相同的位置时，就会相撞。</p>

<ul>
	<li>
	<p>例如，如果一个机器人位于位置 0 并往右移动，另一个机器人位于位置 2 并往左移动，下一秒，它们都将占据位置 1，并改变方向。再下一秒钟后，第一个机器人位于位置 0 并往左移动，而另一个机器人位于位置 2 并往右移动。</p>
	</li>
	<li>
	<p>例如，如果一个机器人位于位置 0 并往右移动，另一个机器人位于位置 1 并往左移动，下一秒，第一个机器人位于位置 0 并往左行驶，而另一个机器人位于位置 1 并往右移动。</p>
	</li>
</ul>
</li>
</ul>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre><b>输入：</b>nums = [-2,0,2], s = "RLL", d = 3
<b>输出：</b>8
<b>解释：</b>
1 秒后，机器人的位置为 [-1,-1,1] 。现在下标为 0 的机器人开始往左移动，下标为 1 的机器人开始往右移动。
2 秒后，机器人的位置为 [-2,0,0] 。现在下标为 1 的机器人开始往左移动，下标为 2 的机器人开始往右移动。
3 秒后，机器人的位置为 [-3,-1,1] 。
下标为 0 和 1 的机器人之间距离为 abs(-3 - (-1)) = 2 。
下标为 0 和 2 的机器人之间的距离为 abs(-3 - 1) = 4 。
下标为 1 和 2 的机器人之间的距离为 abs(-1 - 1) = 2 。
所有机器人对之间的总距离为 2 + 4 + 2 = 8 。
</pre>

<p><strong>示例 2：</strong></p>

<pre><b>输入：</b>nums = [1,0], s = "RL", d = 2
<b>输出：</b>5
<b>解释：</b>
1 秒后，机器人的位置为 [2,-1] 。
2 秒后，机器人的位置为 [3,-2] 。
两个机器人的距离为 abs(-2 - 3) = 5 。
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>2 <= nums.length <= 10<sup>5</sup></code></li>
	<li><code>-2 * 10<sup>9</sup> <= nums[i] <= 2 * 10<sup>9</sup></code></li>
	<li><code>0 <= d <= 10<sup>9</sup></code></li>
	<li><code>nums.length == s.length </code></li>
	<li><code>s</code> 只包含 <code>'L'</code> 和 <code>'R'</code> 。</li>
	<li><code>nums[i]</code> 互不相同。</li>
</ul>

### 思路

### 提示 1

题目最后要求机器人之间的距离，此时把任意两个机器人的位置交换，并不会对答案产生影响。

> 假设 $d$ 秒后机器人的位置数组为 $[1,2,3]$，那么交换成 $[2,1,3]$，所有机器人之间两两距离之和保持不变。

既然如此，那么可以把机器人都看成是**完全一样的，无法区分**。

### 提示 2

相撞等价于**机器人互相穿过对方**，因为我们无法区分机器人。

所以可以无视相撞的规则，把每个机器人都看成是独立运动的。

类似的思路在 [1503. 所有蚂蚁掉下来前的最后一刻](https://leetcode.cn/problems/last-moment-before-all-ants-fall-out-of-a-plank/) 中出现过。

### 提示 3

设 $d$ 秒后机器人的位置数组为 $a$，根据提示 1，可以把数组 $a$ 从小到大排序，再计算所有机器人之间两两距离之和。

从小到大枚举 $a[i]$，此时左边有 $i$ 个数都不超过 $a[i]$，那么 $a[i]$ 与其左侧机器人的距离之和为

$$
\begin{aligned}
&(a[i] - a[0])+ (a[i] - a[1]) + \cdots + (a[i] - a[i-1])\\
=&\ i\cdot a[i] - (a[0] + a[1] + \cdots + a[i-1])
\end{aligned}

$$

其中 $a[0] + a[1] + \cdots + a[i-1]$ 可以一边遍历 $a$，一边计算出来。

```go
const mod int = 1e9 + 7

func sumDistance(a []int, s string, d int) (ans int) {
	for i, v := range a {
		switch s[i] {
		case 'L':
			a[i] = v - d
		case 'R':
			a[i] = v + d
		}
	}
	sort.Ints(a)

	sum := 0
	for i, v := range a {
		ans = (ans + i*v%mod) - sum
		sum += v
	}

	ans = (ans%mod + mod) % mod
	return
}

```
### 复杂度分析

- 时间复杂度：$\mathcal{O}(n\log n)$，其中 $n$ 为 $\textit{nums}$ 的长度。瓶颈在排序上。
- 空间复杂度：$\mathcal{O}(n)$ 或 $\mathcal{O}(1)$。如果需要用一个新的 $\textit{nums}$ 数组记录则需要 $\mathcal{O}(n)$ 空间，否则为 $\mathcal{O}(1)$。
