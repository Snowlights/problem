// Code generated by copypasta/gen/atcoder/generator_test.go
package main

import (
	"problems/testutil/codeforces"
	"testing"
)

// 提交：https://atcoder.jp/contests/agc015/submit?taskScreenName=agc015_d
// 对拍：https://atcoder.jp/contests/agc015/submissions?f.LanguageName=Go&f.Status=AC&f.Task=agc015_d&orderBy=source_length
func Test_run(t *testing.T) {
	t.Log("Current test is [d]")
	testCases := [][2]string{
		{
			`7
			9`,
			`4`,
		},
		{
			`65
			98`,
			`63`,
		},
		{
			`271828182845904523
			314159265358979323`,
			`68833183630578410`,
		},
	}
	codeforces.AssertEqualStringCase(t, run, testCases, 0)
}

// https://atcoder.jp/contests/agc015/tasks/agc015_d

//<p>首先 $[A,B]$ 范围内的每个数都可以取到，先把 $B-A+1$ 加到答案中。</p>
//<p>由于 OR 操作不会让数字变小，接下来只需要考虑：还可以 OR 出哪些大于 $B$ 的数字？</p>
//<p>举例说明。</p>
//<pre><code>B=1011001100
//A=1010110001</code></pre>
//<p>由于 $A$ 和 $B$ 的最长公共前缀 <code>101</code> 肯定是没法改变的，干脆去掉最长公共前缀，只考虑剩余的部分。</p>
//<pre><code>B=1001100
//A=0110001</code></pre>
//<p>此时 $B$ 的最高位一定是 $1$，$A$ 的最高位一定是 $0$。（如果 $A=B$，直接输出 $1$。）</p>
//<h3>第一类构造方案</h3>
//<p>取 $[A,B]$ 内的两个数 $x$ 和 $y$：</p>
//<pre><code>x=1000000 // 只保留最高位的 1
//y=0111111 // x-1 </code></pre>
//<p>这两个数 OR 一下，可以得到最大的数 <code>M=1111111</code>。</p>
//<p>如果继续减少 $y$，只能减少到 $A$，这意味着我们可以得到 $[x|A,M]$ 内的所有数，这一共有 $M-(x|A)+1$ 个数，加到答案中。</p>
//<h3>第二类构造方案</h3>
//<p>取 $[A,B]$ 内的两个数 $p$ 和 $q$：</p>
//<pre><code>p=1001000 // 保留最高位和次高位的 1
//q=1000111 // p-1</code></pre>
//<p>这两个数 OR 一下，得到 <code>M2=1001111</code>。</p>
//<p>继续减少 $q$ 可以一直减少到 $1000000$，这意味着我们可以得到 $[B+1,M_2]$ 内的所有数，这一共有 $M_2-B$ 个数，加到答案中。</p>
//<h3>特殊情况</h3>
//<p>如果 $A$ 最高位的 $1$ 小于等于 $B$ 次高位的 $1$，例如</p>
//<pre><code>B=1001100
//A=0000100</code></pre>
//<p>这会导致 $[B+1,M_2]$ 和 $[x|A,M]$ 有交集，即 $M_2\ge x|A$。</p>
//<p>这两个区间并起来是 $[B+1,M]$，我们可以直接把 $M-B$ 加到答案中。</p>
//<p>代码实现时，由于这些大于 $B$ 的数的最高位都是 $1$，可以在最长公共前缀的基础上再去掉一位。</p>
